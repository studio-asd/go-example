env GOCACHE=$WORK/go/gocache
mkdir $GOCACHE
env GOMODCACHE=$WORK/go/pkg/mod
mkdir $GOMODCACHE
env HOME=$WORK

cd ./database
exec go mod init github.com/testing/testing
exec go mod tidy
exec go run . copyconf --all
exec go run . gengo --all
cd $WORK

cmp ./orders/postgres/sqlc.go golden-sqlc-go

-- database/orders/schema.sql --

CREATE TABLE IF NOT EXISTS orders(
    "order_id" varchar PRIMARY KEY,
    "status" int NOT NULL,
    "created_at" timestamptz NOT NULL,
    "updated_at" timestamptz
);

-- database/orders/query.sql --

-- name: GetOrders :many
SELECT * FROM orders;

-- golden-sqlc-go --
// Code is generated by helper script. DO NOT EDIT.
// This code is generated to replace the SQLC main codes inside sqlc.go
// SQLC:
//   version    : v1.26.0
//   config     : sqlc.yaml
//   sql_package: pgx/v5
//   database   : go_example

package postgres

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/albertwidi/pkg/postgres"
)

type Queries struct {
	db *postgres.Postgres
}

// New returns a new queries instance of go_example database.
func New(db *postgres.Postgres) *Queries {
	return &Queries{db: db}
}

// WithTransact wraps the queries inside a database transaction. The transaction will be committed if no error returned
// and automatically rolled back when an error occured.
func (q *Queries) WithTransact(ctx context.Context, iso sql.IsolationLevel, fn func(ctx context.Context, q *Queries) error) error {
	return q.db.Transact(ctx, iso, func(ctx context.Context, p *postgres.Postgres) error {
		return fn(ctx, New(p))
	})
}

// ensureInTransact ensures the queries are running inside the transaction scope, if the queries is not running inside the a transaction
// the function will trigger WithTransact method. The function doesn't guarantee the subsequent function to have the same isolation level.
//
// As this is only a helper function, please don't use this function if a certain level of isolation is needed.
func (q *Queries) ensureInTransact(ctx context.Context, iso sql.IsolationLevel, fn func(ctx context.Context, q *Queries) error) error {
	inTransaction, isoLevel := q.db.InTransaction()
	if !inTransaction {
		return q.WithTransact(ctx, iso, fn)
	}
	// Don't accept different isolation level between transactions as we will be getting different results.
	if iso != isoLevel {
		return fmt.Errorf("different expectations of isolation level. Got %s but expecting %s", isoLevel, iso)
	}
	return fn(ctx, q)
}

// Do executes queries inside the function fn and allowed other modules to execute queries inside the same transaction scope.
func (q *Queries) Do(ctx context.Context, fn func(ctx context.Context, pg *postgres.Postgres) error ) error {
	return fn(ctx, q.db)
}

-- golden-sqlc-test-go --
// Code is generated by the helper script. DO NOT EDIT.

package postgres

import (
	"context"
	"errors"
	"os"
	"path/filepath"
	"sync"

	"github.com/albertwidi/pkg/postgres"
	testingpkg "github.com/albertwidi/pkg/testing"
	"github.com/albertwidi/pkg/testing/pgtest"

	"github.com/albertwidi/go-example/internal/env"
)

type TestHelper struct {
	dbName string
	testQueries *Queries
	conn *postgres.Postgres
	pgtestHelper *pgtest.PGTest
	// forks is the list of forked helper throughout the test. We need to track the lis of forked helper as we want
	// to track the resource of helper and close them properly.
	forks []*TestHelper
	// fork is a mark that the test helper had been forked, thus several expections should be made when
	// doing several operation like closing connections.
	fork bool
	closeMu sync.Mutex
	closed bool
}

func NewTestHelper(ctx context.Context) (*TestHelper, error) {
	th :=&TestHelper{
		dbName: "orders",
		pgtestHelper: pgtest.New(),
	}
	q, err := th.prepareTest(ctx)
	if err != nil {
		return nil, err
	}
	th.testQueries = q
	return th, nil
}

func (th *TestHelper) Queries() *Queries{
	return th.testQueries
}

// prepareTest prepares the designated postgres database by creating the database and applying the schema. The function returns a postgres connection
// to the database that can be used for testing purposes.
func (th *TestHelper) prepareTest(ctx context.Context) (*Queries, error) {
	pgDSN := env.GetEnvOrDefault("TEST_PG_DSN", "postgres://postgres:postgres@localhost:5432/")
	if err := pgtest.CreateDatabase(ctx, pgDSN, th.dbName, false); err != nil {
		return nil, err
	}

	// Create a new connection with the correct database name.
	config, err := postgres.NewConfigFromDSN(pgDSN)
	if err != nil {
		return nil, err
	}
	config.DBName = th.dbName
	// Connect to the PostgreSQL with the configuration.
	testConn, err := postgres.Connect(context.Background(), config)
	if err != nil {
		return nil, err
	}
	// Read the schema and apply the schema.
	repoRoot, err := testingpkg.RepositoryRoot()
	if err != nil {
		return nil, err
	}
	out, err := os.ReadFile(filepath.Join(repoRoot, "database/ledger/schema.sql"))
	if err != nil {
		return nil, err
	}
	_, err = testConn.Exec(context.Background(), string(out))
	if err != nil {
		return nil, err
	}
	// Assgign the connection for the test helper.
	th.conn = testConn
	return New(testConn), nil
}

// Close closes all connections from the test helper.
func (th *TestHelper) Close() error {
	th.closeMu.Lock()
	defer th.closeMu.Unlock()
	if th.closed {
		return nil
	}

	var err error
	if th.conn != nil {
		errClose := th.conn.Close()
		if errClose != nil {
			err = errors.Join(err, errClose)
		}
	}
	// If not a fork, then we should close all the connections in the test helper as it will closes all connections
	// to the forked schemas. But in fork, we should avoid this as we don't want to control this from forked test helper.
	if !th.fork {
		errClose := th.pgtestHelper.Close()
		if errClose != nil {
			errors.Join(err ,errClose)
		}
		// Closes all the forked helper, this closes the postgres connection in each helper.
		for _, forkedHelper := range th.forks {
			if err := forkedHelper.Close(); err != nil {
				return err
			}
		}
		// Drop the database after test so we will always have a fresh database when we start the test.
		config := th.conn.Config()
		config.DBName = ""
		pg, err := postgres.Connect(context.Background(), config)
		if err != nil {
			return err
		}
		defer pg.Close()
		return pgtest.DropDatabase(context.Background(), pg, th.dbName)
	}
	if err == nil {
		th.closed = true
	}
	return err
}

// ForkPostgresSchema forks the sourceSchema with the underlying connection inside the Queries. The function will return a new connection
// with default search_path into the new schema. The schema name currently is random and cannot be defined by the user.
func (th *TestHelper) ForkPostgresSchema(ctx context.Context, q *Queries, sourceSchema string) (*TestHelper, error) {
	if th.fork {
		return nil, errors.New("cannot fork the schema from a forked test helper, please use the original test helper")
	}
	pg , err:= th.pgtestHelper.ForkSchema(ctx, q.db, sourceSchema)
	if err != nil {
		return nil, err
	}
	newTH := &TestHelper{
		dbName: th.dbName,
		conn: pg,
		testQueries: New(pg),
		pgtestHelper: th.pgtestHelper,
		fork: true,
	}
	// Append the forks to the origin
	th.forks = append(th.forks, newTH)
	return newTH, nil
}
